---
layout: sublime
title: Discipline in Computer Science
date: 2016-04-09T00:00:00.000Z
permalink: discipline_in_computer_science
---

## Computer Science is Not Computer Programming

One of the most common misconceptions about computer science is that it is all about programming. In fact I believed this for a while. How could I not have? My first exposure to computer science was in my AP CS course in high school. Back then the problems were always of the form "Write code to do X", "What is the result of code snippet Y", and "What does 'static' mean in Java". In fact this mentality followed me throughout all of my freshmen year. I remember taking a discrete math course and wondering how any of this stuff applied to my computer science education. I had the mindset that if I wasn't writing it in Java or C++, then it wasn't worth learning. This changed when I took the algorithms course at my university. Algorithms and Models of Computation has truly been the most worthwhile course that I have ever taken. The course changed the way I thought about problems. It gave me the tools to formalize a problem. It gave me the ability to take a problem that I didn't immediately know how to solve and break it down to components that I infact did know how to solve. After taking algorithms I finally understood that computer science was not about programming. I learned that computer science is about problem solving and critical thinking. Computer science is about coming up with processes to generate answers. Programming on the other hand is the act of specifying a process to a computer. Programming is the act of taking a solution to a problem and conveying it in a manner that a computer can understand and execute.

## Errbody want to be a web developer

Everybody wants to be a web developer, but nobody wants to write difficult proofs. Theoretical Computer Science and Web Development are probably on two different ends of career paths for people with computer science degrees. If you ask most of those people which they would rather be, then they would pick web development. The reasons why are obvious. Web pays better, web is easier, web is has more instant gratification. Web is just downright sexier than theory.

This is the trend for people studying computer science. Everybody wants to build an app. Everyone is looking to do something cool to hack together. Everyone is trying to create the next startup. Nobody wants to write a proof. Nobody wants to spend hours in front of a whiteboard. Nobody wants to deal with really hard math. Computer Science is losing its rigor in favor of cushy high paying jobs. People are no longer interested in writing low level code. They just want to play with list comprehensions in Python. People don't want to learn how neural-nets work. They just want to play with the parameters of scikit-learn. Nobody wants to discover solving packing problems, by reducing to max-flow. They just want to know how to crack the coding interview. Computer Science used to be about solving problems, but now it's becoming a trendy career that pays people well for being able to "work with computers".

## Leaf Programmer

The incentives are misaligned. Computer Science pays too well. So many people want a degree suddenly, because they hear that they can make a six figure starting salary for typing on a keyboard. The computer science department at my university has more than doubled in the time I have been there. That level of exponential growth begs the question: "Where are all these CS majors coming from?". It's definitely a perplexing question, since the mother's of the world haven't suddenly doubled the number of computer scientist they give birth to in the last 4 years. What has changed recently is how well computer science pays its graduates. A computer science degree has went from being a passion for solving problems to something that is treated by many as a return on investment.

There are a lot of people who are not interested in computer science for the joy of solving problems. You may wonder where all of these people go. It really varies, since these people can go to work as I.T. for a non technical company or even make it as a software developer at the big four. The reason being is that the only barrier to entry at a tech company is having a resume and passing a technical interview. So to be brutally honest the only thing stopping someone from getting a job after having a degree is the ability to appear competent for 45 minutes in an interview. But surely these people must be competent if they passed an interview. Sadly that is also not the case. Nowadays interviews at tech companies have become all too similar to what the SAT and ACT have become for colleges. They have become standardized. There are entire resources dedicated to helping people pass their technical interview questions. And a lot of interviewers get lazy and pick question directly out of these resources. Interviewers don't want to come up with new ways testing for a candidate's understanding of linked lists. If it isn't a linked list, then it is surely a heap.

Now how do these people maintain their jobs? That is where the markets have come into play. There is a very high demand for software and thus people who can write software. The consequence is that every tech company can afford to have someone who doesn't really know what they are doing as long as they are producing boiler plate code. They need someone to program the button that makes text white on black instead of black on white. They need someone to implement features x, y, and z that only get used sometimes. They need someone to just write code to do things. These people are called by many names. Some call them "leaf programmers", because the code they write is like the leaf of a tree; nobody relies on their code to work and they just write black boxes. Some call them "code monkeys", because in theory if you get enough monkeys typing away at a keyboard, then eventually you will have a copy of Shakespeare. The last one I have heard about is "sweatshop programmers" which points out the fact that they are kind of just there to facilitate the mass production of software.
