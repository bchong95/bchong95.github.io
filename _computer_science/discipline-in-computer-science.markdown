---
layout: sublime
title: Discipline in Computer Science
date: 2016-06-18T10:20:00Z
---

## Computer Science is Not Computer Programming

One of the most common misconceptions about computer science is that it is all about programming. In fact, I believed this for a while. How could I not have? My first exposure to computer science was in my AP CS course in high school. Back then the problems were always so narrow and unsatisfying. "Write a program to do X with the following requirements". "What is the result of code snippet Y when initialized with these values". "What does 'static' mean in Java". In fact this mentality followed me throughout all of my freshmen year. I remember taking a discrete math course and wondering how any of this stuff applied to my computer science education. I had the mindset that if I wasn't writing it in Java or C++, then it wasn't worth learning. This changed when I took the algorithms course at my university. Algorithms and Models of Computation has truly been the most worthwhile course that I have ever taken. The course drastically changed the way I thought about problems. It gave me the tools needed to formalize a problem. It gave me the ability to take a problem that I didn't immediately know how to solve and break it down to components that I in fact did know how to solve. After taking algorithms I finally understood that computer science is not about programming. I learned that computer science is about problem solving and critical thinking. Computer science is the art of coming up with processes to generate answers. Programming on the other hand is the act of specifying a process to a computer. Programming is the act of taking a solution to a problem and conveying it in a manner that a computer can understand and execute.

## Errbody want to be a web developer

Everybody wants to be a web developer, but nobody wants to write difficult proofs. Theoretical computer science and web development are probably on two different ends of career paths for people with computer science degrees. If you ask most of those people which they would rather be, then they would pick web development. The reasons why are obvious. Web pays better, web is easier, web has more instant gratification. Web is just downright sexier than theory.

This is the trend for people studying computer science. Everybody wants to build an app. Everyone is looking to do something cool to hack together. Everyone is trying to create the next startup. But nobody wants to write a proof. Nobody wants to spend hours in front of a whiteboard. Nobody wants to deal with really hard math. Computer science is losing its rigor in favor of cushy high paying jobs. People are no longer interested in writing low level code. They just want to play with list comprehensions in Python. People don't want to learn how neural-nets work. They just want to play with the parameters of scikit-learn. Nobody wants to discover solving packing problems, by reducing to max-flow. They just want to know how to crack the coding interview. Computer science used to be about solving problems, but now it's becoming a trendy career that pays people well for being able to "work with computers".

## Leaf Programmer

The incentives are misaligned. Computer Science pays too well. Many people suddenly want a degree, because they hear that they can make a six figure starting salary for typing on a keyboard. The computer science department at my university has more than doubled its student population in the time I have been there. That level of exponential growth begs the question: "Where are all these CS majors coming from?". It's definitely a perplexing question, since the mothers of the world haven't suddenly doubled the number of computer scientist they give birth to in the last 4 years. What has changed recently is how well computer science pays its graduates. A computer science degree has went from being a passion for solving problems to something that is treated by many as a return on investment.

There are a lot of people who are not interested in computer science for the joy of solving problems. You may wonder where all of these people go. It really varies, since these people can go to work as I.T. for a non technical company or even make it as a software developer at the big four. The reason being is that the only barrier to entry at a tech company is having a resume and passing a technical interview. So to be brutally honest the only thing stopping someone from getting a job after having a degree is the ability to appear competent for 45 minutes in an interview. But these people must be competent if they passed an interview, right? Sadly that is also not the case. Nowadays interviews at tech companies have become all too similar to what the SAT and ACT have become for colleges. They have become standardized. There are entire resources dedicated to helping people pass their technical interview questions and a lot of interviewers get lazy and pick question directly from these resources. Interviewers simply don't want to come up with new ways of testing for a candidate's understanding of linked lists. And if it isn't a linked list, then it must be a heap.

Now how do these people maintain their jobs? That is where the markets have come into play. There is a very high demand for software and thus people who can write software. The consequence is that every tech company can afford to have someone who doesn't really know what they are doing as long as they are producing boiler plate code. They need someone to program the button that makes text white on black instead of black on white. They need someone to implement features x, y, and z. They need someone to just write code to do things. These people are called by many names. Some call them "leaf programmers", because the code they write is like the leaf of a tree; nobody relies on their code to work and they just write black boxes. Some call them "code monkeys", because in theory if you get enough monkeys typing away at a keyboard, then eventually you will have a The Complete Works of Shakespeare. The last one I have heard is "sweatshop programmers" which points out the fact that they are kind of just there to facilitate the mass production of software.

## Web Architects
That is not to say that people who do theoretical computer science are inherently better than those who write web apps. There are various degrees of caliber for both of those categories. There are researchers out there who just "tune" parameters in existing machine learning algorithms and then write a paper on the results. These researchers are just making the appropriate calls to scikit-learn and pushing around a black box Turing machine. There are also excellent web developers out there. A lot of people out there that can make web app, but not all of them know how web development works. They are comfortable making the appropriate calls to jQuery and satisfied that clicking a button does something on their site. They never take a moment to appreciate the rigor that went into making web development a thing.

HTML is the core of how information is rendered in your browser. Internally a web page's HTML is stored in what is known as a "Document Object Model (DOM)". But what a lot of web developers fail to notice is that the DOM is actually a tree. There is a core datastructure powering the DOM. This datastructure is nested and has recursive properties. Just think about the following code in jQuery:

{% highlight JavaScript %}
$('h1');
{% endhighlight %}

 The above code returns a jQuery object for the DOM representation for every header level 1 in your webpage. The code is less than 10 characters long, but internally what is going on is that there is a search being done on a DOM tree. This search is actually an algorithm that takes into account the properties of a tree: "a connected acyclic graph". The person who implemented that search algorithm knew that they could search the DOM tree like a "graph". They also knew that if they started at the root of the tree then they would eventually reach every node, since it is "connected". And finally they didn't need to avoid infinite cycles, because they knew that the tree is "acyclic". There was rigor in coming up with this, but almost none in calling the function.

The people who appreciate these subtleties tend to be the next generation of innovators. These web developers take their understanding of the fundamentals of computer science in order to go out and create things like AngularJS, React, REST, HTTPS, and all the other technologies and protocols we take for granted. These people don't just develop for the web; they architect it.
